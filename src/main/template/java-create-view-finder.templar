{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		PACKAGE DECLARATION, IMPORT STATEMENTS AND CLASS DEFINITION
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

package {database.package}.finder;{\n}{\n}
// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}{\n}

import java.sql.Connection;{\n}
import java.sql.PreparedStatement;{\n}
import java.sql.ResultSet;{\n}
import java.sql.SQLException;{\n}
import java.sql.Types;{\n}
import java.util.List;{\n}
import java.util.Enumeration;{\n}
import java.util.ArrayList;{\n}
import java.util.concurrent.ConcurrentHashMap;{\n}
{\n}
import synapticloop.h2zero.base.exception.H2ZeroFinderException;{\n}
import synapticloop.h2zero.base.manager.ConnectionManager;{\n}
{\n}
import org.apache.log4j.Level;{\n}
import org.apache.log4j.Logger;{\n}
{\n}
import {database.package}.view.{view.javaClassName};{\n}
{\n}

public class {view.javaClassName}ViewFinder {{{\n}

{\t}private static final Logger LOGGER = Logger.getLogger({view.javaClassName}ViewFinder.class);{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
			Is this cacheable?
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{if view.cacheable}
	
	{\t}private static ConcurrentHashMap<String, Boolean> SHOULD_REFRESH_CACHE = new ConcurrentHashMap<String, Boolean>();{\n}
	{\t}private static ConcurrentHashMap<String, List<{view.javaClassName}>> CACHE = new ConcurrentHashMap<String, List<{view.javaClassName}>>();{\n}
{endif}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				FIRST UP THE FIELDS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{\t}private static final String SQL_SELECT_START = "select 
{loop view.fields as field}
	{field.name}
	{if !fieldStatus.last}, {endif}
{endloop}
 from {view.name}";{\n}


{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE FINDER FIELDS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}


{loop view.fields as field}
	{if field.primary}
		{set field.name as primaryFieldName}
		{set field.javaName as primaryFieldJavaName}
	{endif}
{endloop}

{loop view.finders as finder}
	{\t}private static final String SQL_{finder.staticName} = SQL_SELECT_START
	{if fn:notNull[finder.whereClause]} + " {finder.whereClause}"{endif}
	{if fn:notNull[finder.orderBy]} + " order by {finder.orderBy}"{endif};{\n}
{endloop}
{\n}


{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				FIND ALL
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{\t}/**{\n}
{\t} * Find all {view.javaClassName} objects{\n}
{\t} * {\n}
{\t} * @return a list of all of the {view.javaClassName} objects{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the SQL statement{\n}
{\t} */{\n}

{\t}public static List<{view.javaClassName}> findAll() throws SQLException {{{\n}

{if view.cacheFindAll}
	{\t}{\t}if(!shouldRefresh("findAll")) {{{\n}
	{\t}{\t}{\t}List<{view.javaClassName}> results = getCachedResults("findAll");{\n}
	{\t}{\t}{\t}if(null != results) {{{\n}
	{\t}{\t}{\t}{\t}return(results);{\n}
	{\t}{\t}{\t}}{\n}
	{\t}{\t}}{\n}{\n}
{endif}

{\t}{\t}PreparedStatement preparedStatement = null;{\n}
{\t}{\t}ResultSet resultSet = null;{\n}
{\t}{\t}Connection connection = null;{\n}
{\t}{\t}List<{view.javaClassName}> results = new ArrayList<{view.javaClassName}>();{\n}
{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_SELECT_START);{\n}
{\t}{\t}{\t}resultSet = preparedStatement.executeQuery();{\n}
{\t}{\t}{\t}results = list(resultSet);{\n}
{\t}{\t}} catch(SQLException sqlex) {{{\n}
{\t}{\t}{\t}throw sqlex;{\n}
{\t}{\t}} finally {{{\n}
{\t}{\t}{\t}ConnectionManager.closeAll(resultSet, preparedStatement, connection);{\n}
{\t}{\t}}{\n}
{\n}
{if view.cacheFindAll}
	{\t}{\t}refreshCache("findAll", results);{\n}
{endif}

{\t}{\t}return(results);{\n}
{\t}}{\n}
{\n}

{\t}public static List<{view.javaClassName}> findAllSilent() {{{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}return(findAll());{\n}
{\t}{\t}} catch(SQLException sqlex){{{\n}

{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.WARN)) {{{\n}
{\t}{\t}{\t}LOGGER.warn("SQLException: " + sqlex.getMessage());{\n}
{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}return(new ArrayList<{view.javaClassName}>());{\n}
{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Return the results as a list of {view.javaClassName}, this will be empty if{\n}
{\t} * none are found.{\n}
{\t} * {\n}
{\t} * @param resultSet the results as a list of {view.javaClassName}{\n}
{\t} * {\n}
{\t} * @return the list of results{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was a problem retrieving the results{\n}
{\t} */{\n}

{\t}private static List<{view.javaClassName}> list(ResultSet resultSet) throws SQLException {{{\n}
{\t}{\t}List<{view.javaClassName}> ArrayList = new ArrayList<{view.javaClassName}>();{\n}
{\t}{\t}while(resultSet.next()) {{{\n}

{\t}{\t}{\t}ArrayList.add(new {view.javaClassName}({\n}

{loop view.fields as field}
	{\t}{\t}{\t}{\t}{\t}resultSet.get{field.sqlJavaType}({fieldStatus.index})
	{if !fieldStatus.last},{\n}{endif}
{endloop}
));{\n}

{\t}{\t}}{\n}
{\t}{\t}return(ArrayList);{\n}
{\t}}{\n}
{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
			Is this cacheable?
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{if view.cacheable}
{\t}/**{\n}
{\t} * Return whether this finder name should be refreshed{\n}
{\t} *{\n}
{\t} * @param finderName The name of the finder{\n}
{\t} *{\n}
{\t} * @return whether this cache needs a refresh{\n}
{\t} */{\n}
{\t}public static boolean shouldRefresh(String finderName) {{{\n}
{\t}{\t}if(LOGGER.isDebugEnabled()) {{{\n}
{\t}{\t}{\t}LOGGER.debug("Should refresh individual cache for finder '" + finderName + "': '" + SHOULD_REFRESH_CACHE.containsKey(finderName) + "'.");{\n}
{\t}{\t}}{\n}
{\t}{\t}return(SHOULD_REFRESH_CACHE.containsKey(finderName));{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Refresh the cache with a list of variables{\n}
{\t} *{\n}
{\t} * @param finderName the name of the finder{\n}
{\t} *{\n}
{\t} * @param results the results to set in the cache{\n}
{\t} */{\n}
{\t}public synchronized static void refreshCache(String finderName, List<{view.javaClassName}> results) {{{\n}
{\t}{\t}if(LOGGER.isDebugEnabled()) {{{\n}
{\t}{\t}{\t}LOGGER.debug("Attempting to refresh cache for finder '" + finderName + "', with results: " + results);{\n}
{\t}{\t}}{\n}
{\t}{\t}SHOULD_REFRESH_CACHE.remove(finderName);{\n}
{\t}{\t}CACHE.put(finderName, results);{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Get the cached results for a specific finder{\n}
{\t} *{\n}
{\t} * @param finderName the name of the finder to get the results for{\n}
{\t} *{\n}
{\t} * @return the cached results, or null if not available{\n}
{\t} */{\n}
{\t}public static List<{view.javaClassName}> getCachedResults(String finderName) {{{\n}
{\t}{\t}return(CACHE.get(finderName));{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Mark an individual finder cache as ready for refresh{\n}
{\t} *{\n}
{\t} * @param finderName the name of the finder method to refresh{\n}
{\t} */{\n}
{\t}public static void markCacheShouldBeRefreshed(String finderName) {{{\n}
{\t}{\t}if(!SHOULD_REFRESH_CACHE.containsKey(finderName)) {{{\n}
{\t}{\t}{\t}if(LOGGER.isDebugEnabled()) {{{\n}
{\t}{\t}{\t}{\t}LOGGER.debug("Marking cache for finder '" + finderName + "' ready for refresh.");{\n}
{\t}{\t}{\t}}{\n}
{\n}
{\t}{\t}{\t}SHOULD_REFRESH_CACHE.put(finderName, true);{\n}
{\t}{\t}} else {{{\n}
{\t}{\t}{\t}if(LOGGER.isDebugEnabled()) {{{\n}
{\t}{\t}{\t}{\t}LOGGER.debug("Cache for finder '" + finderName + "' already marked for refresh.");{\n}
{\t}{\t}{\t}}{\n}
{\t}{\t}}{\n}
{\t}}{\n}
{\n}
{endif}
}

